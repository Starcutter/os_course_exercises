# lec6 SPOC思考题


NOTICE
- 有"w3l2"标记的题是助教要提交到学堂在线上的。
- 有"w3l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 与视频相关思考题

### 6.1	非连续内存分配的需求背景
1. 为什么要设计非连续内存分配机制？

	**答**：提高内存利用效率和管理灵活性。

2. 非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变?

	**答**：可以采用段式内存管理或页式内存管理，段式块大小可变，页式块大小固定。


3. 为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？

	**答**：大块大小可变比较灵活，避免大量浪费；小块因为本身占空间小，设计成固定大小可以方便操作系统进行内存管理。固定大小在同一台机器上应是一致的，比如4KB一页，不同机器的页大小可以不一样。

### 6.2	段式存储管理
 1. 什么是段、段基址和段内偏移？

	**答**：段表示访问方式和存储数据等属性相同的一段地址空间。段基址是段的起始位置在线性地址空间中的地址。段内偏移是目标内存单元相对于段基址的偏移量。

 2. 段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

 	**答**：由段选择子在段表中找到段基址，再加上段内偏移，得到线性地址。由于一个段内的数据或程序是逻辑上连贯的一块，访问这些数据或程序时各段之间相互独立，所以不同的段可以存储在不连续的位置。好处是不连续分配可以方便内存管理，麻烦是地址转换机制复杂。


### 6.3	页式存储管理
 1. 什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？

 	**答**：页是逻辑地址空间被划分成的相同大小的基本分配单位。帧是物理地址被划分成的相同大小的基本分配单位。一个页可以映射为一个帧。页表是内存中保存了各页和各帧映射关系的数据结构。存储管理单元是用来进行虚拟-物理地址转换的硬件。快表是部分页表的缓存。高速缓存是比内存访问速度更快的存储设备，用来存储内存中常被访问的数据，以提高访存速度。
 
 2. 页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各页的存储位置可以不连续？这种做法有什么好处和麻烦？

 	**答**：逻辑地址分为页号和页内偏移两段，根据页号从页表中查找到对应的帧号，即帧在物理地址中的基地址，再加上偏移量，得到物理地址。因为页表中每一项对应了一组页和帧的映射，不同的页会被影射到不同的位置，所以各页的存储位置可以不连续。好处是方便内存管理，麻烦是访存开销变大。


### 6.4	页表概述
 1. 每个页表项有些什么内容？有哪些标志位？它们起什么作用？

 	**答**：页表项内有帧号和标志位。标志位分为：
 	
 	- 存在位：这个页是否存在与之对应的帧
 	- 修改位：这个页中的内容是否被修改过
 	- 引用位：过去一段时间内是否有访问过这个页内的存储单元
 
 2. 页表大小受哪些因素影响？

 	**答**：逻辑内存大小、页大小、进程数量。


### 6.5	快表和多级页表
 1. 快表（TLB）与高速缓存（cache）有什么不同？

 	**答**：快表是CPU中页表的缓存，只会存储页表中的部分内容。
 
 2. 为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？

	**答**：因为计算机访问数据存在空间和时间局部性，最近被访问过的，以及空间上相邻的数据被访问的概率更大，快表将近期访问过的页表项存储在CPU中，命中率较高，一旦命中可以直接找到帧号，存储介质的访问速度也比内存快，所以速度非常快。使用关联存储实现。容量小是因为存储介质成本高，而且CPU上空间有限。
 
 3. 什么是多级页表？多级页表中的地址转换流程是什么？多级页表有什么好处和麻烦？

 	**答**：通过间接引用将页号分为多级，建立多个页表，形成树结构。将逻辑地址中的一级页号拿出来，在一级页表中查找得到二级页号，再到二级页表中查询，递归进行，直到查找到最终的帧号，再加上偏移量即可。好处是减小了页表大小，麻烦是多次访问导致访存开销更大了。


### 6.6	反置页表
 1. 页寄存器机制的地址转换流程是什么？

	**答**：用逻辑页号进行hash，找到对应的页寄存器，每个页寄存器和一个物理帧号对应。如果有冲突，就遍历所有冲突项，和里面存储的逻辑页号进行比较，找到正确的那一个。
 
 2. 反置页表机制的地址转换流程是什么？

	**答**：和页寄存器类似，只不过是使用进程号和逻辑页号一起hash，再去核对hash到的页寄存器里面存储的进程号和逻辑页号，如果有冲突，就根据next域找下一个。
 
 3. 反置页表项有些什么内容？

 	**答**：进程号、逻辑页号、标志位、next域。

### 6.7	段页式存储管理
 1. 段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？

	**答**：逻辑地址包括段号、页号和偏移量，通过段号查找段表，找到一个页表基址，根据页号在这个页表中找到帧号，再加上偏移量得到物理地址。好处是结合了段式内存管理在内存保护等方面的优势，和页式内存管理在内存利用与转移方面的优势，麻烦在于访存开销加大。
 
 2. 如何实现基于段式存储管理的内存共享？

	**答**：设置共享段，添加进两个进程的段表中。
 
 3. 如何实现基于页式存储管理的内存共享？

 	**答**：让两个进程页表中的某项都指向相同的物理帧。

## 个人思考题
（1） (w3l2) 请简要分析64bit CPU体系结构下的分页机制是如何实现的



## 小组思考题
（1）(spoc) 某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10^-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10^-6s),求不在内存的页面的平均访问时间。请给出计算步骤。



（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示映射不存在。
PFN6..0:页帧号
PT6..0:页表的物理基址>>5
```
在[物理内存模拟数据文件](./03-2-spoc-testdata.md)中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。
```
1) Virtual Address 6c74
   Virtual Address 6b22
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```

比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)
```
Virtual Address 7570:
  --> pde index:0x1d  pde contents:(valid 1, pfn 0x33)
    --> pte index:0xb  pte contents:(valid 0, pfn 0x7f)
      --> Fault (page table entry not valid)

Virtual Address 21e1:
  --> pde index:0x8  pde contents:(valid 0, pfn 0x7f)
      --> Fault (page directory entry not valid)

Virtual Address 7268:
  --> pde index:0x1c  pde contents:(valid 1, pfn 0x5e)
    --> pte index:0x13  pte contents:(valid 1, pfn 0x65)
      --> Translates to Physical Address 0xca8 --> Value: 16
```

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，请说明原因。

（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，提交你的实现，并说明区别。

（4）假设你有一台支持[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。

 (5)[X86的页面结构](http://os.cs.tsinghua.edu.cn/oscourse/OS2018spring/lecture06)
---

## 扩展思考题

阅读64bit IBM Powerpc CPU架构是如何实现[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)，给出分析报告。


## interactive　understand VM

[Virtual Memory with 256 Bytes of RAM](http://blog.robertelder.org/virtual-memory-with-256-bytes-of-ram/)：这是一个只有256字节内存的一个极小计算机系统。按作者的[特征描述](https://github.com/RobertElderSoftware/recc#what-can-this-project-do)，它具备如下的功能。
 - CPU的实现代码不多于500行；
 - 支持14条指令、进程切换、虚拟存储和中断；
 - 用C实现了一个小的操作系统微内核可以在这个CPU上正常运行；
 - 实现了一个ANSI C89编译器，可生成在该CPU上运行代码；
 - 该编译器支持链接功能；
 - 用C89, Python, Java, Javascript这4种语言实现了该CPU的模拟器；
 - 支持交叉编译；
 - 所有这些只依赖标准C库。
 
针对op-cpu的特征描述，请同学们通过代码阅读和执行对自己有兴趣的部分进行分析，给出你的分析结果和评价。
